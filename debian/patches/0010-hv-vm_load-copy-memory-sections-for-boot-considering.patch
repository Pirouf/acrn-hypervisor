From 4cce3cdcf92cf33579075ba51c6eecff955854e8 Mon Sep 17 00:00:00 2001
From: Helmut Buchsbaum <helmut.buchsbaum@opensource.tttech-industrial.com>
Date: Wed, 10 Jun 2020 16:32:36 +0200
Subject: hv: vm_load: copy memory sections for boot considering possible
 intersections

Since large ramdisk might already been loaded in a memory range which might
used by the target range for the kernel image, check if copying the memory
ranges in reverse order might solve the problem without distroying data.
See the following figure for a real life, problematic scenario:

as loaded            as placed
by the               by ACRN
bootloader           for SOS boot
+------+             +------+
|      |             |      |
+------+0x10000      |      |
|      |             |      |
|kernel|             |      |
|image |             |      |
|      |             |      |
+------+0xdfc6a0     |      |
|      |             |      |
+------+0xdfd000     |      |
|      |             |      |
|      |             |      |
| ram  |             |      |
| disk |             |      |
|      |          ~~ +------+0x1000000
|      |     OVERLAP!|      |
+------+0x1ce32ef ~~ |kernel|
|      |             |image |
|      |             |      |
|      |             +------+0x1cfc6a0
|      |             |      |
|      |             +------+0x1cfd000
|      |             |      |
|      |             |      |
|      |             | ram  |
|      |             | disk |
|      |             |      |
|      |             |      |
|      |             +------+
|      |             |      |
|      |             |      |

Signed-off-by: Helmut Buchsbaum <helmut.buchsbaum@opensource.tttech-industrial.com>
---
 hypervisor/common/vm_load.c | 92 +++++++++++++++++++++++++++++--------
 1 file changed, 73 insertions(+), 19 deletions(-)

diff --git a/hypervisor/common/vm_load.c b/hypervisor/common/vm_load.c
index de9b580d..af64e942 100644
--- a/hypervisor/common/vm_load.c
+++ b/hypervisor/common/vm_load.c
@@ -178,6 +178,75 @@ static void prepare_loading_rawimage(struct acrn_vm *vm)
 	sw_kernel->kernel_entry_addr = (void *)vm_config->os_config.kernel_entry_addr;
 }
 
+/*
+ * check if two memory ranges intersect
+ */
+static bool intersects(void *addr1, uint32_t size1, void *addr2, uint32_t size2)
+{
+	return (addr1 <= (addr2 + size2)) && (addr2 <= (addr1 + size1));
+}
+
+/*
+ * copy memory sections for boot considering possible intersections
+ */
+static int32_t direct_boot_image_copy(struct acrn_vm *vm)
+{
+	int32_t ret;
+
+	struct sw_kernel_info *kinfo = &(vm->sw.kernel_info);
+	struct sw_module_info *rinfo = &(vm->sw.ramdisk_info);
+	struct sw_module_info *binfo = &(vm->sw.bootargs_info);
+
+	if (vm->sw.ramdisk_info.size == 0U) {
+		/* no ramdisk --> kernel only */
+		/* Copy the guest kernel image to its run-time location */
+		ret = copy_to_gpa(vm, kinfo->kernel_src_addr,
+			(uint64_t)kinfo->kernel_load_addr, kinfo->kernel_size);
+
+	/* check if kernel destination range interferes with ramdisk source range */
+	} else if (intersects(kinfo->kernel_load_addr, kinfo->kernel_size,
+		       rinfo->src_addr, rinfo->size)) {
+
+		/* check if ramdisk destination range interferes with kernel source range */
+		if (intersects(rinfo->load_addr, rinfo->size,
+			       kinfo->kernel_src_addr, kinfo->kernel_size)) {
+			/* no way to copy ranges without overwriting them! */
+			pr_err("Cannot copy kernel/ramdisk without overwriting");
+			return -EINVAL;
+		}
+		/* Copy RAM disk to its load location */
+		ret = copy_to_gpa(vm, rinfo->src_addr,
+			(uint64_t)rinfo->load_addr, rinfo->size);
+		if (ret)
+			return ret;
+
+		/* Copy the guest kernel image to its run-time location */
+		ret = copy_to_gpa(vm, kinfo->kernel_src_addr,
+			(uint64_t)kinfo->kernel_load_addr, kinfo->kernel_size);
+	} else {
+		/* Copy the guest kernel image to its run-time location */
+		ret = copy_to_gpa(vm, kinfo->kernel_src_addr,
+			(uint64_t)kinfo->kernel_load_addr, kinfo->kernel_size);
+		if (ret)
+			return ret;
+
+		/* Copy RAM disk to its load location */
+		ret = copy_to_gpa(vm, rinfo->src_addr,
+			(uint64_t)rinfo->load_addr, rinfo->size);
+	}
+
+	if (ret)
+		return ret;
+
+	/* Finally, copy Guest OS bootargs to its load location */
+	if (binfo->size != 0U) {
+		ret = copy_to_gpa(vm, binfo->src_addr,
+			(uint64_t)binfo->load_addr,
+			(strnlen_s((char *)binfo->src_addr, MAX_BOOTARGS_SIZE) + 1U));
+	}
+	return ret;
+}
+
 /**
  * @pre vm != NULL
  */
@@ -185,8 +254,6 @@ int32_t direct_boot_sw_loader(struct acrn_vm *vm)
 {
 	int32_t ret = 0;
 	struct sw_kernel_info *sw_kernel = &(vm->sw.kernel_info);
-	struct sw_module_info *bootargs_info = &(vm->sw.bootargs_info);
-	struct sw_module_info *ramdisk_info = &(vm->sw.ramdisk_info);
 	/* get primary vcpu */
 	struct acrn_vcpu *vcpu = vcpu_from_vid(vm, BSP_CPU_ID);
 
@@ -198,23 +265,10 @@ int32_t direct_boot_sw_loader(struct acrn_vm *vm)
 	 *      guest boot mode (real mode vs protect mode)
 	 */
 	init_vcpu_protect_mode_regs(vcpu, get_guest_gdt_base_gpa(vcpu->vm));
-
-	/* Copy the guest kernel image to its run-time location */
-	(void)copy_to_gpa(vm, sw_kernel->kernel_src_addr,
-		(uint64_t)sw_kernel->kernel_load_addr, sw_kernel->kernel_size);
-
-	/* Check if a RAM disk is present */
-	if (ramdisk_info->size != 0U) {
-		/* Copy RAM disk to its load location */
-		(void)copy_to_gpa(vm, ramdisk_info->src_addr,
-			(uint64_t)ramdisk_info->load_addr,
-			ramdisk_info->size);
-	}
-	/* Copy Guest OS bootargs to its load location */
-	if (bootargs_info->size != 0U) {
-		(void)copy_to_gpa(vm, bootargs_info->src_addr,
-			(uint64_t)bootargs_info->load_addr,
-			(strnlen_s((char *)bootargs_info->src_addr, MAX_BOOTARGS_SIZE) + 1U));
+	ret = direct_boot_image_copy(vm);
+	if (ret) {
+		pr_err("direct_boot_image_copy() failed: %d", ret);
+		return ret;
 	}
 	switch (vm->sw.kernel_type) {
 	case KERNEL_BZIMAGE:
-- 
2.20.1

