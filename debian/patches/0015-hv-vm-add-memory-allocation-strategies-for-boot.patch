From: Helmut Buchsbaum <helmut.buchsbaum@opensource.tttech-industrial.com>
Date: Tue, 5 May 2020 20:33:39 +0200
Subject: hv: vm: add memory allocation strategies for boot

In preparation to support the Linux kernel boot protocol regarding
memory usage to avoid crashes when trying to place images to already
used locations, provide allocation strategies that find appropriate
memory within the E820 tables of a VM from low memory end and from
top of memory (needed to place initramfs as required).

Signed-off-by: Helmut Buchsbaum <helmut.buchsbaum@opensource.tttech-industrial.com>
---
 hypervisor/arch/x86/guest/vm.c         | 153 +++++++++++++++++++++++++++++++++
 hypervisor/include/arch/x86/guest/vm.h |   4 +
 2 files changed, 157 insertions(+)

diff --git a/hypervisor/arch/x86/guest/vm.c b/hypervisor/arch/x86/guest/vm.c
index bb50e8c..180284f 100644
--- a/hypervisor/arch/x86/guest/vm.c
+++ b/hypervisor/arch/x86/guest/vm.c
@@ -393,6 +393,156 @@ static uint64_t lapic_pt_enabled_pcpu_bitmap(struct acrn_vm *vm)
 	return bitmap;
 }
 
+/*
+ * Allocate E820 ram for VM
+ *
+ * @param[inout] vm pointer to a vm descriptor
+ * @param[in] size of requested memory range
+ * @param[in] pa_addr preferred address, 0 means don't care
+ * @param[in] relocatable if false accept pa_addr only
+ *
+ * @retval pointer to mem, NULL on failure
+ *
+ */
+void *vm_allocate(struct acrn_vm *vm, uint32_t size, uint64_t pa_addr,
+	bool relocatable)
+{
+	uint32_t i;
+	void *address = NULL;
+
+	if (!relocatable && pa_addr < vm->boot_allocator_top)
+		goto out;
+
+	/* try to find the required section */
+	if (pa_addr != 0) {
+		for (i = 0; i < vm->e820_entry_num; ++i) {
+			struct e820_entry *e820 = &vm->e820_entries[i];
+
+			/* no RAM section */
+			if (e820->type != E820_TYPE_RAM)
+				continue;
+			/* range does not fit */
+			if ((pa_addr < e820->baseaddr) ||
+			    ((pa_addr + size) > (e820->baseaddr + e820->length)) ||
+			    (pa_addr < vm->boot_allocator_top)) {
+				continue;
+			}
+
+			address = gpa2hva(vm, pa_addr);
+			/* found! */
+			if (address) {
+				vm->boot_allocator_top = pa_addr + size;
+				goto out;
+			}
+			break;
+		}
+	}
+
+	/* no section found, retry relocatable */
+	if (!relocatable)
+		return NULL;
+
+	for (i = 0; i < vm->e820_entry_num; ++i) {
+		struct e820_entry *e820 = &vm->e820_entries[i];
+
+		/* no RAM section */
+		if (e820->type != E820_TYPE_RAM)
+			continue;
+		/* RAM below  vm->top_allocated */
+		if ((e820->baseaddr + e820->length) < vm->boot_allocator_top)
+			continue;
+
+		if (e820->baseaddr < vm->boot_allocator_top) {
+			if ((e820->baseaddr + e820->length) < (vm->boot_allocator_top + size))
+				continue;
+
+			address = gpa2hva(vm, vm->boot_allocator_top);
+			if (address) {
+				vm->boot_allocator_top += size;
+				goto out;
+			}
+			continue;
+		}
+
+		if (e820->length < size)
+			continue;
+
+		address = gpa2hva(vm, e820->baseaddr);
+		if (address) {
+			vm->boot_allocator_top = e820->baseaddr + size;
+			goto out;
+		}
+	}
+out:
+	return address;
+}
+
+/*
+ * Allocate E820 ram for VM from top down
+ *
+ * @param[inout] vm pointer to a vm descriptor
+ * @param[in] size of requested memory range
+ * @param[in] max_end preferred end address +1 of memblock
+ *
+ * @retval pointer to mem, NULL on failure
+ *
+ */
+void *vm_allocate_top(struct acrn_vm *vm, uint32_t size, uint64_t max_end)
+{
+	int i;
+	void *address = NULL;
+	uint64_t max_start = max_end - size;
+
+	if (max_start < vm->boot_allocator_top)
+		goto out;
+
+	for (i = vm->e820_entry_num -1; i >= 0; --i) {
+		struct e820_entry *e820 = &vm->e820_entries[i];
+		uint64_t entry_end = e820->baseaddr + e820->length;
+
+		/* no RAM section */
+		if (e820->type != E820_TYPE_RAM) {
+			continue;
+		}
+
+		if (entry_end <= vm->boot_allocator_top) {
+			break;
+		}
+		if (e820->baseaddr > max_start) {
+			continue;
+		}
+
+		if ((e820->baseaddr <= max_start) &&
+		    (max_end <= entry_end) &&
+		    ((entry_end - vm->boot_allocator_top) >= size)) {
+			address = gpa2hva(vm, max_start);
+			if (address) {
+				/* found at max address */
+				vm->boot_allocator_top = max_end;
+				goto out;
+			}
+			continue;
+		}
+
+		if (e820->length < size) {
+			continue;
+		}
+
+		if ((entry_end - vm->boot_allocator_top) < size) {
+			goto out;
+		}
+
+		address = gpa2hva(vm, entry_end - size);
+		if (address) {
+			/* found at max address */
+			vm->boot_allocator_top = entry_end;
+			goto out;
+		}
+	}
+out:
+	return address;
+}
+
 /**
  * @pre vm_id < CONFIG_MAX_VM_NUM && vm_config != NULL && rtn_vm != NULL
  * @pre vm->state == VM_POWERED_OFF
@@ -409,6 +559,9 @@ int32_t create_vm(uint16_t vm_id, uint64_t pcpu_bitmap, struct acrn_vm_config *v
 	vm->vm_id = vm_id;
 	vm->hw.created_vcpus = 0U;
 
+	/* skip lower mem for allocation */
+	vm->boot_allocator_top = CONFIG_LOW_RAM_SIZE;
+
 	init_ept_mem_ops(&vm->arch_vm.ept_mem_ops, vm->vm_id);
 	vm->arch_vm.nworld_eptp = vm->arch_vm.ept_mem_ops.get_pml4_page(vm->arch_vm.ept_mem_ops.info);
 	sanitize_pte((uint64_t *)vm->arch_vm.nworld_eptp, &vm->arch_vm.ept_mem_ops);
diff --git a/hypervisor/include/arch/x86/guest/vm.h b/hypervisor/include/arch/x86/guest/vm.h
index 6f80fbb..616ef65 100644
--- a/hypervisor/include/arch/x86/guest/vm.h
+++ b/hypervisor/include/arch/x86/guest/vm.h
@@ -156,6 +156,7 @@ struct acrn_vm {
 	uint8_t vrtc_offset;
 
 	uint64_t intr_inject_delay_delta; /* delay of intr injection */
+	uint64_t boot_allocator_top; /* top of bootmem allocated for sos boot */
 } __aligned(PAGE_SIZE);
 
 /*
@@ -239,6 +240,9 @@ bool is_prelaunched_vm(const struct acrn_vm *vm);
 uint16_t get_vmid_by_uuid(const uint8_t *uuid);
 struct acrn_vm *get_vm_from_vmid(uint16_t vm_id);
 struct acrn_vm *get_sos_vm(void);
+void *vm_allocate(struct acrn_vm *vm, uint32_t size, uint64_t pa_addr,
+	bool relocatable);
+void *vm_allocate_top(struct acrn_vm *vm, uint32_t size, uint64_t top);
 
 void create_sos_vm_e820(struct acrn_vm *vm);
 void create_prelaunched_vm_e820(struct acrn_vm *vm);
