From: Victor Sun <victor.sun@intel.com>
Date: Tue, 2 Jun 2020 21:31:35 +0800
Subject: HV: add hv cmdline support for multiboot2

The multiboot2 cmdline would be used as hypervisor cmdline, add parse logic
for the case that hypervisor boot from multiboot2 protocol.

Tracked-On: #4885

Signed-off-by: Victor Sun <victor.sun@intel.com>
Reviewed-by: Yin Fengwei <fengwei.yin@intel.com>
Acked-by: Eddie Dong <eddie.dong@intel.com>
---
 hypervisor/boot/cmdline.c      | 13 ++++---------
 hypervisor/boot/include/boot.h |  5 +++++
 hypervisor/boot/multiboot.c    |  6 ++++--
 hypervisor/boot/multiboot2.c   |  4 ++++
 4 files changed, 17 insertions(+), 11 deletions(-)

diff --git a/hypervisor/boot/cmdline.c b/hypervisor/boot/cmdline.c
index 79096d5..72bed57 100644
--- a/hypervisor/boot/cmdline.c
+++ b/hypervisor/boot/cmdline.c
@@ -9,19 +9,14 @@
 #include <boot.h>
 #include <pgtable.h>
 #include <dbg_cmd.h>
-#include <logmsg.h>
 
 void parse_hv_cmdline(void)
 {
-	const char *start = NULL;
-	const char *end = NULL;
+	const char *start = NULL, *end = NULL;
+	struct acrn_multiboot_info *mbi = &acrn_mbi;
 
-	if (boot_from_multiboot1()) {
-		struct multiboot_info *mbi = (struct multiboot_info *)(hpa2hva_early((uint64_t)boot_regs[1]));
-
-		if ((mbi->mi_flags & MULTIBOOT_INFO_HAS_CMDLINE) != 0U) {
-			start = (char *)hpa2hva_early((uint64_t)mbi->mi_cmdline);
-		}
+	if ((mbi->mi_flags & MULTIBOOT_INFO_HAS_CMDLINE) != 0U) {
+		start = mbi->mi_cmdline;
 	}
 
 	while ((start != NULL) && ((*start) != '\0')) {
diff --git a/hypervisor/boot/include/boot.h b/hypervisor/boot/include/boot.h
index 1b664a6..51ff94c 100644
--- a/hypervisor/boot/include/boot.h
+++ b/hypervisor/boot/include/boot.h
@@ -73,6 +73,11 @@ static inline bool boot_from_multiboot2(void)
 int32_t multiboot2_to_acrn_mbi(struct acrn_multiboot_info *mbi, void *mb2_info);
 #endif
 
+/*
+ * The extern declaration for acrn_mbi is for cmdline.c use only, other functions should use
+ * get_multiboot_info() API to access struct acrn_mbi because it has explict @post condition
+ */
+extern struct acrn_multiboot_info acrn_mbi;
 struct acrn_multiboot_info *get_multiboot_info(void);
 void init_acrn_multiboot_info(void);
 int32_t sanitize_multiboot_info(void);
diff --git a/hypervisor/boot/multiboot.c b/hypervisor/boot/multiboot.c
index 9f3f17b..473f4ea 100644
--- a/hypervisor/boot/multiboot.c
+++ b/hypervisor/boot/multiboot.c
@@ -11,7 +11,7 @@
 #include <rtl.h>
 #include <logmsg.h>
 
-static struct acrn_multiboot_info acrn_mbi = { 0U };
+struct acrn_multiboot_info acrn_mbi = { 0U };
 
 static int32_t mbi_status;
 
@@ -50,8 +50,10 @@ int32_t sanitize_multiboot_info(void)
 	} else if (boot_from_multiboot2()) {
 		pr_info("Multiboot2 detected.");
 		mmap_entry_size = sizeof(struct multiboot2_mmap_entry);
-	}
 #endif
+	} else {
+		/* mbi_status is still -ENODEV, nothing to do here */
+	}
 
 	if ((acrn_mbi.mi_mmap_entries != 0U) && (acrn_mbi.mi_mmap_va != NULL)) {
 		if (acrn_mbi.mi_mmap_entries > E820_MAX_ENTRIES) {
diff --git a/hypervisor/boot/multiboot2.c b/hypervisor/boot/multiboot2.c
index 955d09d..3875450 100644
--- a/hypervisor/boot/multiboot2.c
+++ b/hypervisor/boot/multiboot2.c
@@ -72,6 +72,10 @@ int32_t multiboot2_to_acrn_mbi(struct acrn_multiboot_info *mbi, void *mb2_info)
 
 	while ((mb2_tag->type != MULTIBOOT2_TAG_TYPE_END) && (mb2_tag < mb2_tag_end)) {
 		switch (mb2_tag->type) {
+		case MULTIBOOT2_TAG_TYPE_CMDLINE:
+			mbi->mi_cmdline = ((struct multiboot2_tag_string *)mb2_tag)->string;
+			mbi->mi_flags |= MULTIBOOT_INFO_HAS_CMDLINE;
+			break;
 		case MULTIBOOT2_TAG_TYPE_MMAP:
 			mb2_mmap_to_mbi(mbi, (const struct multiboot2_tag_mmap *)mb2_tag);
 			break;
