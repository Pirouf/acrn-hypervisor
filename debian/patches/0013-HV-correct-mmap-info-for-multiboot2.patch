From a0145938b4317eed782bf92517759d017996027f Mon Sep 17 00:00:00 2001
From: Victor Sun <victor.sun@intel.com>
Date: Mon, 8 Jun 2020 16:13:31 +0800
Subject: HV: correct mmap info for multiboot2

The acrn_mbi.mi_mmap_va should point to struct multiboot2_mmap_entry when
boot from multiboot2, which is different from struct multiboot_mmap when
boot from multiboot1. So we should handle mmap info separately for multiboot2.

Tracked-On: #4885

Signed-off-by: Victor Sun <victor.sun@intel.com>
---
 hypervisor/boot/multiboot.c | 40 +++++++++++++++++++------------------
 1 file changed, 21 insertions(+), 19 deletions(-)

diff --git a/hypervisor/boot/multiboot.c b/hypervisor/boot/multiboot.c
index 2b99d20b..b7b01ca4 100644
--- a/hypervisor/boot/multiboot.c
+++ b/hypervisor/boot/multiboot.c
@@ -41,29 +41,31 @@ void init_acrn_multiboot_info(void)
 
 int32_t sanitize_multiboot_info(void)
 {
-	uint32_t mmap_entry_size = 0U;
-
-	if (boot_from_multiboot1()) {
-		pr_info("Multiboot1 detected.");
-		mmap_entry_size = sizeof(struct multiboot_mmap);
-#ifdef CONFIG_MULTIBOOT2
-	} else if (boot_from_multiboot2()) {
-		pr_info("Multiboot2 detected.");
-		mmap_entry_size = sizeof(struct multiboot2_mmap_entry);
-#endif
-	} else {
-		/* mbi_status is still -ENODEV, nothing to do here */
-	}
-
 	if ((acrn_mbi.mi_mmap_entries != 0U) && (acrn_mbi.mi_mmap_va != NULL)) {
 		if (acrn_mbi.mi_mmap_entries > E820_MAX_ENTRIES) {
 			pr_err("Too many E820 entries %d\n", acrn_mbi.mi_mmap_entries);
 			acrn_mbi.mi_mmap_entries = E820_MAX_ENTRIES;
 		}
-		(void)memcpy_s((void *)(&acrn_mbi.mi_mmap_entry[0]),
-			(acrn_mbi.mi_mmap_entries * mmap_entry_size),
-			(const void *)acrn_mbi.mi_mmap_va,
-			(acrn_mbi.mi_mmap_entries * mmap_entry_size));
+		if (boot_from_multiboot1()) {
+			uint32_t mmap_entry_size = sizeof(struct multiboot_mmap);
+
+			(void)memcpy_s((void *)(&acrn_mbi.mi_mmap_entry[0]),
+				(acrn_mbi.mi_mmap_entries * mmap_entry_size),
+				(const void *)acrn_mbi.mi_mmap_va,
+				(acrn_mbi.mi_mmap_entries * mmap_entry_size));
+		}
+#ifdef CONFIG_MULTIBOOT2
+		if (boot_from_multiboot2()) {
+			uint32_t i;
+			struct multiboot2_mmap_entry *mb2_mmap = (struct multiboot2_mmap_entry *)acrn_mbi.mi_mmap_va;
+
+			for (i = 0U; i < acrn_mbi.mi_mmap_entries; i++) {
+				acrn_mbi.mi_mmap_entry[i].baseaddr = (mb2_mmap + i)->addr;
+				acrn_mbi.mi_mmap_entry[i].length = (mb2_mmap + i)->len;
+				acrn_mbi.mi_mmap_entry[i].type = (mb2_mmap + i)->type;
+			}
+		}
+#endif
 		acrn_mbi.mi_flags |= MULTIBOOT_INFO_HAS_MMAP;
 	} else {
 		acrn_mbi.mi_flags &= ~MULTIBOOT_INFO_HAS_MMAP;
@@ -106,7 +108,7 @@ int32_t sanitize_multiboot_info(void)
 		pr_err("no bootloader name found!");
 		mbi_status = -EINVAL;
 	} else {
-		printf("Detect bootloader: %s\n", acrn_mbi.mi_loader_name);
+		printf("Multiboot%s Bootloader: %s\n", boot_from_multiboot1() ? "" : "2", acrn_mbi.mi_loader_name);
 	}
 
 	return mbi_status;
-- 
2.20.1

